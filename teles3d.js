// Generated by CoffeeScript 1.8.0
var Pixel2D, Pixel3D, teles3d;

Pixel3D = (function() {
  function Pixel3D() {}

  Pixel3D.prototype.nX = 0;

  Pixel3D.prototype.nY = 0;

  Pixel3D.prototype.nZ = 0;

  return Pixel3D;

})();

Pixel2D = (function() {
  function Pixel2D() {}

  Pixel2D.prototype.nX = 0;

  Pixel2D.prototype.nY = 0;

  return Pixel2D;

})();

teles3d = (function() {
  var nCosTxCosP, nCosTxSinP, nI, nSinTxCosP, nSinTxSinP, nX, nX0, nX1, nX2, nY0, nY1, nZ0, nZ1, nZ2, oPix, _i;

  function teles3d(canvas, width, height) {
    this.ctx = canvas.getContext("2d");
    this.nVisaoX = 0;
    this.nVisaoZ = 0;
    this.nEscalaX = 0;
    this.nEscalaY = 0;
    this.nTamanhoX = width;
    this.nTamanhoY = height;
    this.nCentroX = width / 2;
    this.nCentroY = height / 2;
    this.nCamH = 0;
    this.nCamV = 0;
    this.nProfun = 100;
    this.backColor = "black";
    this.foreColor = "white";
  }

  teles3d.prototype.clear = function() {
    return this.ctx.clearRect(0, 0, this.nTamanhoX, this.nTamanhoY);
  };

  teles3d.prototype.AlterCam = function(nAngH, nAngV, nDepthX, nDepthY) {
    this.nCamH = nAngH;
    this.nCamV = nAngV;
    this.nEscalaX = nDepthX;
    return this.nEscalaY = nDepthY;
  };

  teles3d.prototype.AlterColor = function(cor) {
    return this.ctx.strokeStyle = cor;
  };

  teles3d.prototype.AlterVisao = function(tnX, tnZ) {
    this.nVisaoX = tnX;
    return this.nVisaoZ = tnZ;
  };

  teles3d.prototype.Cart2Pixel = function(tnP, tcTipo) {
    var nK;
    nK = 0;
    if (tcTipo === 'X') {
      nK = (tnP * this.nEscalaX) + this.nCentroX;
    } else {
      nK = (tnP * this.nEscalaY) + this.nCentroY;
    }
    return nK;
  };

  teles3d.prototype._3DTo2D = function(toPixel3d) {
    var nCosP, nCosT, nDepth, nPhi, nSinP, nSinT, nTheta;
    nTheta = Math.PI * this.nCamH / 180.0;
    nPhi = Math.PI * this.nCamV / 180.0;
    nDepth = 600;
    nCosT = Math.cos(nTheta);
    nSinT = Math.sin(nTheta);
    nCosP = Math.cos(nPhi);
    return nSinP = Math.sin(nPhi);
  };

  nCosTxCosP = nCosT * nCosP;

  nCosTxSinP = nCosT * nSinP;

  nSinTxCosP = nSinT * nCosP;

  nSinTxSinP = nSinT * nSinP;

  nX0 = toPixel3d.nX;

  nY0 = toPixel3d.nY;

  nZ0 = -toPixel3d.nZ;

  nX1 = nCosT * nX0 + nSinT * nZ0;

  nY1 = -nSinTxSinP * nX0 + nCosP * nY0 + nCosTxSinP * nZ0;

  nZ1 = (nCosTxCosP * nZ0) - (nSinTxCosP * nX0) - (nSinP * nY0);

  oPix = new Pixel2D();

  oPix.nX = (nX1 * nDepth) / (nZ1 + nDepth);

  oPix.nY = (nY1 * nDepth) / (nZ1 + nDepth);

  oPix;

  teles3d.prototype.DrawLine = function(oPixel1, oPixel2) {
    var nAng, nI, nLin, nMax, nMin, nX, nX2, nY, nY2, oPex1, oPex2, _i;
    oPex1 = this._3DTo2D(oPixel1);
    oPex2 = this._3DTo2D(oPixel2);
    nX1 = this.Cart2Pixel(oPex1.nX, 'X');
    nX2 = this.Cart2Pixel(oPex2.nX, 'X');
    nY1 = this.Cart2Pixel(oPex1.nY, 'Y');
    nY2 = this.Cart2Pixel(oPex2.nY, 'Y');
    nAng = 0;
    nLin = 0;
    nX = 0;
    nY = 0;
    nMax = 0;
    nMin = 0;
    if ((nX2 - nX1) === 0) {
      nAng = 0;
    } else {
      nAng = (nY2 - nY1) / (nX2 - nX1);
    }
    nLin = nY1 - (nAng * nX1);
    nMin = Math.min(nX1, nX2);
    nMax = Math.max(nX1, nX2);
    this.ctx.beginPath();
    for (nI = _i = nMin; nMin <= nMax ? _i <= nMax : _i >= nMax; nI = nMin <= nMax ? ++_i : --_i) {
      nY = Math.round(nAng * nI + nLin);
      this.ctx.fillRect(nI, nY, 1, 1);
    }
    nMin = Math.min(nY1, nY2);
    return nMax = Math.max(nY1, nY2);
  };

  for (nI = _i = nMin; nMin <= nMax ? _i <= nMax : _i >= nMax; nI = nMin <= nMax ? ++_i : --_i) {
    if (nAng === 0) {
      nX = nX1;
    } else {
      nX = Math.round((nI - nLin) / nAng);
    }
    teles3d.ctx.fillRect(nX, nI, 1, 1);
  }

  teles3d.ctx.closePath();

  teles3d.ctx.stroke();

  teles3d.prototype.AlterAng = function(tnAng, tnX1, tnZ1, tnX2, tnZ2) {
    var nRad, nX2, nZ2, ret1, ret2;
    nRad = 6.28318531 - tnAng;
    nX1 = 0;
    nZ1 = 0;
    nX2 = 0;
    nZ2 = 0;
    ret1 = new Point3D();
    return ret2 = new Point3D();
  };

  nX1 = tnX1 - nVisaoX;

  nX2 = tnX2 - nVisaoX;

  nZ1 = tnZ1 - nVisaoZ;

  nZ2 = tnZ2 - nVisaoZ;

  ret1.nX = (nX1 * cos(nRad)) + (nZ1 * -sin(nRad));

  ret1.nZ = (nX1 * sin(nRad)) + (nZ1 * cos(nRad));

  ret2.nX = (nX2 * cos(nRad)) + (nZ2 * -sin(nRad));

  ret2.nZ = (nX2 * sin(nRad)) + (nZ2 * cos(nRad));

  ret1.nX = ret1.nX + nVisaoX;

  ret2.nX = ret2.nX + nVisaoX;

  ret1.nZ = ret1.nZ + nVisaoZ;

  ret2.nZ = ret2.nZ + nVisaoZ;

  [ret1, ret2];

  teles3d.prototype.Line3D = function(tnAng, tnX1, tnY1, tnZ1, tnX2, tnY2, tnZ2) {
    var oPix1, oPix2;
    oPix1 = new Pixel3D();
    oPix2 = new Pixel3D();
    oPix = this.AlterAng(tnAng, tnX1, tnZ1, tnX2, tnZ2);
    oPix[0].nY = tnY1;
    oPix[1].nY = tnY2;
    return this.DrawLine(oPix[0], oPix[1]);
  };

  teles3d.prototype.Point3D = function(tnX, tnY, tnZ) {
    var oPix1, oPix2;
    oPix1 = new Pixel3D();
    oPix2 = new Pixel3D();
    oPix1.nX = tnX;
    oPix1.nY = tnY;
    oPix1.nZ = tnZ;
    oPix2.nX = tnX + 0.1;
    oPix2.nY = tnY + 0.1;
    oPix2.nZ = tnZ + 0.1;
    return this.DrawLine(oPix1, oPix2);
  };

  teles3d.prototype.CircleX3D = function(tnAng, tnX, tnY, tnZ, tnRaio) {
    var nCX, nCY, nRad, nTam, oAnt, oPixel, _j, _results;
    nCX = tnX;
    nCY = tnY;
    nTam = tnRaio;
    oPixel = new Pixel3D();
    oAnt = new Pixel3D();
    _results = [];
    for (nI = _j = 0; _j <= 360; nI = ++_j) {
      nRad = nI * (Math.PI / 180);
      oPixel.nX = nCX + (Math.cos(nRad) * nTam);
      oPixel.nY = nCY + (Math.sin(nRad) * nTam);
      oPixel.nZ = tnZ;
      if (nI > 0) {
        this.Line3D(tnAng, oAnt.nX, oAnt.nY, oAnt.nZ, oPixel.nX, oPixel.nY, oPixel.nZ);
      }
      oAnt.nX = oPixel.nX;
      oAnt.nY = oPixel.nY;
      _results.push(oAnt.nZ = oPixel.nZ);
    }
    return _results;
  };

  teles3d.prototype.CircleY3D = function(tnAng, tnX, tnY, tnZ, tnRaio) {
    var nCY, nCZ, nRad, nTam, oAnt, oPixel, _j;
    nCY = tnY;
    nCZ = tnZ;
    nTam = tnRaio;
    oPixel = new Pixel3D();
    oAnt = new Pixel3D();
    for (nI = _j = 0; _j <= 360; nI = ++_j) {
      nRad = nI * (Math.PI / 180);
    }
    oPixel.nY = nCY + (Math.cos(nRad) * nTam);
    oPixel.nZ = nCZ + (Math.sin(nRad) * nTam);
    oPixel.nX = tnX;
    if (nI > 0) {
      this.Line3D(tnAng, oAnt.nX, oAnt.nY, oAnt.nZ, oPixel.nX, oPixel.nY, oPixel.nZ);
    }
    oAnt.nX = oPixel.nX;
    oAnt.nY = oPixel.nY;
    return oAnt.nZ = oPixel.nZ;
  };

  teles3d.prototype.CircleZ3D = function(tnAng, tnX, tnY, tnZ, tnRaio) {
    var nCX, nCZ, nRad, nTam, oAnt, oPixel, _j;
    nCX = tnX;
    nCZ = tnZ;
    nTam = tnRaio;
    oPixel = new Pixel3D();
    oAnt = new Pixel3D();
    for (nI = _j = 0; _j <= 360; nI = ++_j) {
      nRad = nI * (Math.PI / 180);
    }
    oPixel.nX = nCX + (Math.cos(nRad) * nTam);
    oPixel.nZ = nCZ + (Math.sin(nRad) * nTam);
    oPixel.nY = tnY;
    if (nI > 0) {
      this.Line3D(tnAng, oAnt.nX, oAnt.nY, oAnt.nZ, oPixel.nX, oPixel.nY, oPixel.nZ);
    }
    oAnt.nX = oPixel.nX;
    oAnt.nY = oPixel.nY;
    return oAnt.nZ = oPixel.nZ;
  };

  teles3d.prototype.SquareX3D = function(tnAng, tnX, tnY, tnZ, tnTamX, tnTamY) {
    var Z0, nXT, nYT;
    nX0 = tnX;
    nY0 = tnY;
    Z0 = tnZ;
    nXT = nX0 + tnTamX;
    nYT = nY0 + tnTamY;
    this.Line3D(tnAng, nX0, nY0, Z0, nX0, nYT, Z0);
    this.Line3D(tnAng, nX0, nY0, Z0, nXT, nY0, Z0);
    this.Line3D(tnAng, nX0, nYT, Z0, nXT, nYT, Z0);
    return this.Line3D(tnAng, nXT, nY0, Z0, nXT, nYT, Z0);
  };

  teles3d.prototype.SquareZ3D = function(tnAng, tnX, tnY, tnZ, tnTamZ, tnTamY) {
    var nYT, nZT;
    nX0 = tnX;
    nY0 = tnY;
    nZ0 = tnZ;
    nYT = nY0 + tnTamY;
    nZT = nZ0 + tnTamZ;
    this.Line3D(tnAng, nX0, nY0, nZ0, nX0, nYT, nZ0);
    this.Line3D(tnAng, nX0, nY0, nZ0, nX0, nY0, nZT);
    this.Line3D(tnAng, nX0, nYT, nZ0, nX0, nYT, nZT);
    return this.Line3D(tnAng, nX0, nY0, nZT, nX0, nYT, nZT);
  };

  teles3d.prototype.Cube3D = function(tnAng, tnX, tnY, tnZ, tnTamX, tnTamY, tnTamZ) {
    var Z0;
    nX0 = tnX - tnTamX / 2;
    nY0 = tnY;
    return Z0 = tnZ - tnTamZ / 2;
  };

  teles3d.SquareX3D(tnAng, nX0, nY0, Z0, tnTamX, tnTamY);

  teles3d.SquareX3D(tnAng, nX0, nY0, Z0 + tnTamZ, tnTamX, tnTamY);

  teles3d.SquareZ3D(tnAng, nX0, nY0, Z0, tnTamZ, tnTamY);

  teles3d.SquareZ3D(tnAng, nX0 + tnTamX, nY0, Z0, tnTamZ, tnTamY);

  teles3d.prototype.Plan = function(tnTam, tnLargura) {};

  nX0 = 0 - tnTam;

  nY0 = 0;

  nZ0 = tnTam;

  nI = nX0;

  while (nI < tnTam) {
    teles3d.Line3D(0, nI, nY0, nZ0, nI, nY0, nZ0 - (2 * tnTam));
    nI += tnLargura;
  }

  nI = nZ0;

  while (nI >= -tnTam) {
    teles3d.Line3D(0, nX0, nY0, nI, nX0 + (2 * tnTam), nY0, nI);
    nI = nI - tnLargura;
  }

  return teles3d;

})();
